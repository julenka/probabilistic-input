<!DOCTYPE html>
<html>
<head>
    <title>OverlayFeedback Demo</title>

    <!-- Julia library -->
    <script type="text/javascript" src="../dist/julia.js"></script>

    <!-- Julia CSS -->
    <link type="text/css" rel="stylesheet" href="../julia.css"/>
    <style>
        #demo_result {
            margin-top: -350px;
            font-family: Helvetica Neue, Helvetica, Arial;
            font-size: xx-large;
            width: 100%;
            height: 100%;
            text-align: center;
        }
    </style>
</head>
<body>


<div id="ipad_container" class="ipad_container">
    <div id="ipad_screen" class="ipad_screen">
        <svg id="demo_interface" width="546" height="407"></svg>

    </div>
</div>
<div id="debug"></div>
<div id="demo_result"></div>


<script>
// Add any controls here
var Target = FSMView.subClass({
    className: "Target",
    init: function(julia, props) {
        var defaults = {
            label: "default",
            // which icons can drop onto you
            droppable_icons: [],
            w: 50,
            h: 50,
            x: 100,
            y: 100,
            cap_p: 0.05,
            cap_dist: 200,
            message: "default message"
        };
        this._super(julia, props, defaults);
        this.fsm_description = {
            start: [
            /**
             * attrs: to (required), source (required), type (required), predicate (required), feedback_action (default: undefined)
             * final_action (default: undefined), handles_event (default: false)
             * @param attrs
             */
                new Transition({
                    to: "active",
                    source: "virtual",
                    type: "dragstart",
                    predicate: function(e) {
                        if(this.attr("droppable_icons").indexOf(e.view.attr("type")) >= 0 ) {
                            return true;
                        } else {
                            return false;
                        }
                    },
                    feedback_action: DO_NOTHING,
                    handles_event: false
                })
            ],
            active: [
                new Transition({
                    to: "start",
                    source: "virtual",
                    type: "dragend",
                    predicate: RETURN_TRUE,
                    feedback_action: DO_NOTHING,
                    handles_event: false
                }),
                new TransitionWithProbability({
                    to: "over",
                    source: "virtual",
                    type: "dragprogress",
                    predicate: this.overPredicate,
                    feedback_action: DO_NOTHING,
                    handles_event: false
                }),
                new TransitionWithProbability({
                    to: "active",
                    source: "virtual",
                    type: "dragprogress",
                    predicate: function(e) {
                        if(this.hitTest(e)) {
                            return false;
                        }
                        var dist = this.getDistFrom(e.view);
                        if(dist > this.attr("cap_dist")) {
                            return this.attr("cap_p");
                        }
                        var result = this.attr("cap_p") + this.attr("cap_p") * Math.pow((1 - (dist / this.attr("cap_dist"))), 1);
                        return result;
                    },
                    feedback_action: DO_NOTHING,
                    handles_event: true
                }),
            ],
            over: [
                new Transition({
                    to: "active",
                    source: "virtual",
                    type: "dragprogress",
                    predicate: this.missTest,
                    feedback_action: DO_NOTHING,
                    handles_event: false
                }),
                new TransitionWithProbability({
                    to: "over",
                    source: "virtual",
                    type: "dragprogress",
                    feedback_action: this.hitTest,
                    predicate: this.overPredicate,
                    handles_event: true
                }),
                new Transition({
                    to: "start",
                    source: "virtual",
                    type: "dragend",
                    predicate: RETURN_TRUE,
                    feedback_action: this.onDragEnd,
                    handles_event: true
                })
            ]
        }
    },
    overPredicate: function(e) {
        if(this.missTest(e)) {
            return 0;
        };
        var dist = this.getDistFrom(e.view);
        var max_dist = this.attr("w") * 2;
        var result = 0.5 + 0.5 * (1 - (dist / max_dist));
//                        console.log(result);
        return result;
    },
    getDistFrom: function(other) {
        return $V([this.attr("x"), this.attr("y")]).distanceFrom($V([other.attr("x"), other.attr("y")]));
    },
    missTest: function(e) {
        return !this.hitTest(e);
    },
    hitTest: function(e){
        var r1 = e.view.getBoundingBox();
        var r2 = this.getBoundingBox();
        return rectanglesIntersect(r1, r2);
    },
    onDragEnd: function(e, rootView) {
//        console.log("onDragEnd");
        var child = rootView.findViewById(e.view.__julia_id);
        child.properties.x = e.view.drag_start_info.my_x;
        child.properties.y = e.view.drag_start_info.my_y;
        var $menuResultDiv = $("#demo_result");
        $menuResultDiv.html(this.properties.message);
        $menuResultDiv.fadeIn(1000,function(){
            $menuResultDiv.fadeOut();
        });
    },

    draw: function($el) {

        if(this.current_state === "start") {
            return;
        }
        var s = Snap($el[0]);
        var x = this.properties.x;
        var y = this.properties.y;
        var w = this.properties.w;
        var cx = x + w / 2;
        var cy = y + w / 2;
        if(this.current_state === "active") {
            s.circle(cx, cy, w / 2).attr({
                stroke: "gray",
                fill: "white",
                "fill-opacity": 0.9,
                "stroke-width": "1px"
            });
            s.text(cx,cy + 5, this.attr("label")).attr({
                fill:  "gray",
                "text-anchor": "middle"
            });
        } else {
            s.circle(cx, cy, w / 2).attr({
                stroke: "green",
                fill: "white",
                "fill-opacity": 0.9,
                "stroke-width": "3px"
            });
            s.text(cx,cy + 5, this.attr("label")).attr({
                fill:  "green",
                "text-anchor": "middle"
            });
        }


    }
    });
    var Icon = DraggableShape.subClass({
        className: "Icon",
        /**
         * de
         * @param julia
         * @param properties
         */
        init: function(julia, properties) {
            this._super(julia, properties);

        },

        drawShape: function($el) {
            var s = Snap($el[0]);
            s.rect(this.attr("x"), this.attr("y"), this.attr("w"), this.attr("h")).attr({
                fill: this.attr("color")
            });
            s.text(this.attr("x"), this.attr("y") + 30, this.attr("type")).attr({fill: "white"});
        },
        drawDragFeedback: function($el) {
            var s = Snap($el[0]);
            var padding = 5;
            s.rect(this.attr("x") - padding, this.attr("y") - padding, this.attr("w") + 2 * padding, this.attr("h") + 2 * padding).attr({
                stroke: "black",
                fill: "white"
            });
        },
    });

</script>

<script>
    var julia;
    var $sketch = $("#demo_interface");
    var $debug = $("#debug");
    var centerX = $sketch.width() / 2;
    var centerY = $sketch.height() / 2;
    var iconJitter = 50;
    var iconSize = 50;
    var mouseVariance = 10;

    function targetPos(deg, i) {
        var r = 150;
        var resultR = 30;
        var theta = deg / 180 * Math.PI;
        var resultX = Math.cos(theta) * r + centerX - resultR;
        var resultY = Math.sin(theta) * r + centerY - resultR;

        resultX = i * resultR * 3;
        resultY = 50;
        return {x: resultX, y: resultY, w: resultR * 2, h: resultR * 2};


    }

    function iconAttrs(i){
        var w = 60;
        return {
            x: centerX + i * w - 1.5 * w,
            y: centerY ,
            w: iconSize,
            h: iconSize
        };
    }

    function setup() {
        // Set up views
        var rootView = new ContainerView(julia);
        julia.setRootView(rootView);

        var imgIcon = new Icon(julia, $.extend({type: "image", color: "red"}, iconAttrs(0)));
        var musicIcon = new Icon(julia, $.extend({type: "mp3", color: "green"}, iconAttrs(1)));
        var wifiIcon = new Icon(julia, $.extend({type: "wifi", color: "blue"}, iconAttrs(2)));

        rootView.addChildView(imgIcon);
        rootView.addChildView(musicIcon);
        rootView.addChildView(wifiIcon);

        var targets = [
            ["data", ["wifi"], "checking data..."],
            ["disable", ["wifi"], "turning off wifi..."],
            ["playlist", ["mp3"], "adding song to playlist..."],
            ["share", ["mp3","image"], "sharing..."],
            ["adjust", ["image"], "adjusting image..."],
            ["crop", ["image"], "cropping image..."],
            ["share", ["image"], "sharing image..."]
        ];
        var everyChildView = new EveryChildContainerView(julia);
        targets.forEach(function(t, i) {
            var deg = i * 90 ;
            everyChildView.addChildView(
                    new Target(julia, $.extend(
                        {
                            label: t[0],
                            droppable_icons: t[1],
                            message: t[2]
                        },
                        targetPos(deg,i)))
            );
        });
        rootView.addChildView(everyChildView);
    }

    // Put your initialization code here
    $(document).ready(function(){

        julia = new Julia( {
            nSamplesPerEvent: 5
        });

//        var feedback = new OverlayFeedback(julia, {feedbackType: OverlayOpacity, showOriginal: false});
        var feedback = new OverlayFeedback(julia, {feedbackType: OverlayScale, showOriginal: false});
//        var feedback = new OverlayFeedback(julia, {feedbackType: OverlayContrast, showOriginal: false});
//        var feedback = new OverlayFeedback(julia, {feedbackType: OverlayProgressBar, showOriginal: false});
        julia.addEventSource(new PMouseEventHook($sketch[0], mouseVariance, mouseVariance));

        setup();

        var updateUI = function() {
            $sketch.empty();
            julia.drawFeedback($sketch, feedback);
        };
        updateUI();
        // Do stuff when an event has been dispatched
        julia.dispatchCompleted = function(x, uiUpdated) {
            if(!uiUpdated) {
                return;
            }
            updateUI();
//            julia.dumpAlternativesAsSnap($debug, $sketch.width(), $sketch.height(), 0.4);
        };

        addTouchOverlay();
    });

</script>
</body>
</html>