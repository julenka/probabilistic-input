<!DOCTYPE html>
<html>
<head>
    <title>OverlayFeedback Demo</title>

    <!-- Julia library -->
    <script type="text/javascript" src="../dist/julia.js"></script>

    <!-- Julia CSS -->
    <link type="text/css" rel="stylesheet" href="../julia.css"/>
    <style>
        #demo_result {
            margin-top: -350px;
            font-family: Helvetica Neue, Helvetica, Arial;
            font-size: xx-large;
            width: 100%;
            height: 100%;
            text-align: center;
        }
        #demo_interface {
            /*background-image: url("../imgs/ipad_bg4.jpg");*/
        }
    </style>
</head>
<body>

<div style="height: 100px"></div>
<div id="ipad_container" class="ipad_container">
    <div id="ipad_screen" class="ipad_screen">
        <svg id="demo_interface" width="546" height="407"></svg>

    </div>
</div>
<!--<div id="debug"></div>-->
<div id="demo_result"></div>


<script>
// Add any controls here
var Target = FSMView.subClass({
    className: "Target",
    init: function(julia, props) {
        var defaults = {
            label: "default",
            // which icons can drop onto you
            droppable_icons: [],
            w: 50,
            h: 50,
            x: 100,
            y: 100,
            cap_p: 0.05,
            cap_dist: 150,
            message: "default message"
        };
        this._super(julia, props, defaults);
        this.fsm_description = {
            start: [
            /**
             * attrs: to (required), source (required), type (required), predicate (required), feedback_action (default: undefined)
             * final_action (default: undefined), handles_event (default: false)
             * @param attrs
             */
                new Transition({
                    to: "active",
                    source: "virtual",
                    type: "dragstart",
                    predicate: function(e) {
                        if(this.attr("droppable_icons").indexOf(e.view.attr("type")) >= 0 ) {
                            return true;
                        } else {
                            return false;
                        }
                    },
                    feedback_action: DO_NOTHING,
                    handles_event: false
                })
            ],
            active: [
                new Transition({
                    to: "start",
                    source: "virtual",
                    type: "dragend",
                    predicate: RETURN_TRUE,
                    feedback_action: DO_NOTHING,
                    handles_event: false
                }),
                new TransitionWithProbability({
                    to: "over",
                    source: "virtual",
                    type: "dragprogress",
                    predicate: this.overPredicate,
                    feedback_action: DO_NOTHING,
                    handles_event: true
                }),
                new TransitionWithProbability({
                    to: "active",
                    source: "virtual",
                    type: "dragprogress",
                    predicate: function(e) {
                        if(this.hitTest(e)) {
                            return 0;
                        }
                        var dist = this.getDistFrom(e.view);
                        if(dist > this.attr("cap_dist")) {
                            return this.attr("cap_p");
                        }
                        var result = this.attr("cap_p") + (1 - this.attr("cap_p")) * Math.pow((1 - (dist / this.attr("cap_dist"))), 1);
                        return result;
                    },
                    feedback_action: DO_NOTHING,
                    handles_event: false
                }),
//                new TransitionWithProbability({
//                    to: "active",
//                    source: "virtual",
//                    type: "dragprogress",
//                    predicate: function(e) {
//                        if(this.hitTest(e)) {
//                            return 0;
//                        }
//                        var dist = this.getDistFrom(e.view);
//                        if(dist > this.attr("cap_dist")) {
//                            return this.attr("cap_p");
//                        }
//                        var result = this.attr("cap_p") + (1 - this.attr("cap_p")) * Math.pow((1 - (dist / this.attr("cap_dist"))), 1);
//                        return result;
//                    },
//                    feedback_action: DO_NOTHING,
//                    handles_event: false
//                }),
            ],
            over: [
                new Transition({
                    to: "active",
                    source: "virtual",
                    type: "dragprogress",
                    predicate: this.missTest,
                    feedback_action: DO_NOTHING,
                    handles_event: false
                }),
                new TransitionWithProbability({
                    to: "over",
                    source: "virtual",
                    type: "dragprogress",
                    feedback_action: this.hitTest,
                    predicate: this.overPredicate,
                    handles_event: false
                }),
                new Transition({
                    to: "start",
                    source: "virtual",
                    type: "dragend",
                    predicate: RETURN_TRUE,
                    feedback_action: this.onDragEnd,
                    handles_event: false
                })
            ]
        }
    },
    overPredicate: function(e) {
        if(this.missTest(e)) {
            return 0;
        };
        var dist = this.getDistFrom(e.view);
        var max_dist = this.attr("w");
        var result =  0.9 + 0.1 * (1 - (dist / max_dist));
//                        console.log(result);
        return result;
    },
    getDistFrom: function(other) {
        return $V([this.attr("x"), this.attr("y")]).distanceFrom($V([other.attr("x"), other.attr("y")]));
    },
    missTest: function(e) {
        return !this.hitTest(e);
    },
    hitTest: function(e){
        var r1 = e.view.getBoundingBox();
        var r2 = this.getBoundingBox();
        return rectanglesIntersect(r1, r2);
    },
    onDragEnd: function(e, rootView) {
//        console.log("onDragEnd");
        var child = rootView.findViewById(e.view.__julia_id);
        child.properties.x = e.view.drag_start_info.my_x;
        child.properties.y = e.view.drag_start_info.my_y;
        var $menuResultDiv = $("#demo_result");
        $menuResultDiv.html(this.properties.message);
        $menuResultDiv.fadeIn(1000,function(){
            $menuResultDiv.fadeOut();
        });
    },

    draw: function($el) {


        var s = Snap($el[0]);
        var x = this.properties.x;
        var y = this.properties.y;
        var w = this.properties.w;
        var cx = x + w / 2;
        var cy = y + w / 2;
        if(this.current_state === "start") {
//            s.circle(cx, cy, w / 2).attr({
//                stroke: "gray",
//                fill: "white",
//                "fill-opacity": 0.01,
//                "stroke-width": "1px",
//                "stroke-opacity": 0.2
//            });
//            s.text(cx,cy + 5, this.attr("label")).attr({
//                fill:  "gray",
//                "fill-opacity": 0.01,
//                "text-anchor": "middle",
//                "stroke-opacity": 0.2
//            });
//            return;
        } else if(this.current_state === "active") {
            s.circle(cx, cy, w / 2).attr({
                stroke: "gray",
                fill: "white",
                "fill-opacity": 0.5,
                "stroke-width": "1px"
            });
            s.text(cx,cy + 5, this.attr("label")).attr({
                fill:  "gray",
                "text-anchor": "middle"
            });
        } else {
            s.circle(cx, cy, w / 2).attr({
                stroke: "green",
                fill: "green",
                "fill-opacity": 0.1,
                "stroke-width": "3px"
            });
            s.text(cx,cy + 5, this.attr("label")).attr({
                fill:  "green",
                "text-anchor": "middle"
            });
        }


    }
    });
    var Icon = DraggableShape.subClass({
        className: "Icon",
        /**
         * de
         * @param julia
         * @param properties
         */
        init: function(julia, properties) {
            this._super(julia, properties);

        },

        drawShape: function($el) {
            var s = Snap($el[0]);
//            s.rect(this.attr("x"), this.attr("y"), this.attr("w"), this.attr("h")).attr({
//                fill: this.attr("color")
//            });
            var textColor = this.current_state === "dragging" ? "white":"black";
            s.text(this.attr("x"), this.attr("y") + 70, this.attr("label")).attr({fill: textColor});
            var x = this.attr("x");
            var y = this.attr("y");
            var w = this.attr("w");
            var h = this.attr("h");
            s.image(this.attr("src"), x, y, 50, 50);
        },
        drawDragFeedback: function($el) {
            var s = Snap($el[0]);
            var padding = 10;
            s.rect(this.attr("x") - padding, this.attr("y") + 65 - padding,
                            this.attr("w") + 2 * padding,
                            20,
                    10, 10).attr({
                stroke: "black",
                fill: "#5776F1"

            });

        },
    });

</script>

<script>
    var julia;
    var $sketch = $("#demo_interface");
    var $debug = $("#debug");
    var centerX = $sketch.width() / 2;
    var centerY = $sketch.height() / 2;
    var iconJitter = 50;
    var iconSize = 50;
    var mouseVariance = 1;

    function targetPos(deg, i) {
        var r = 150;
        var resultR = 30;
        var theta = deg / 180 * Math.PI;
        var resultX = Math.cos(theta) * r + centerX - resultR;
        var resultY = Math.sin(theta) * r + centerY - resultR;

        resultX = i * resultR * 3 + 15;
        resultY = 50;
        return {x: resultX, y: resultY, w: resultR * 2, h: resultR * 2};


    }

    function iconAttrs(i){
        var w = 60;
        return {
            x: centerX + i * w - 1.5 * w,
            y: centerY ,
            w: iconSize,
            h: iconSize
        };
    }

    function setup() {
        // Set up views
        var rootView = new ContainerView(julia);
        julia.setRootView(rootView);

        var imgIcon = new Icon(julia, $.extend({label: "my.png", type: "image", color: "red", src:"../imgs/image.png"}, iconAttrs(0)));
        var musicIcon = new Icon(julia, $.extend({label: "my.mp3", type: "mp3", color: "green", src:"../imgs/musical-note.png"}, iconAttrs(1)));
        var wifiIcon = new Icon(julia, $.extend({label: "my_wifi", type: "wifi", color: "blue", src:"../imgs/wifi.png"}, iconAttrs(2)));



        var targets = [
            ["data", ["wifi"], "checking data..."],
            ["disable", ["wifi"], "turning off wifi..."],
            ["playlist", ["mp3"], "adding song to playlist..."],
            ["share", ["mp3","image"], "sharing..."],
            ["adjust", ["image"], "adjusting image..."],
            ["crop", ["image"], "cropping image..."],
        ];
//        var everyChildView = new EveryChildContainerView(julia);
        targets.forEach(function(t, i) {
            var deg = i * 90 ;
            rootView.addChildView(
                    new Target(julia, $.extend(
                        {
                            label: t[0],
                            droppable_icons: t[1],
                            message: t[2]
                        },
                        targetPos(deg,i)))
            );
        });
//        rootView.addChildView(everyChildView);

        rootView.addChildView(imgIcon);
        rootView.addChildView(musicIcon);
        rootView.addChildView(wifiIcon);
    }

    // Put your initialization code here
    $(document).ready(function(){

        julia = new Julia( {
            nSamplesPerEvent: 5
        });

        var feedback = new MostLikelyFeedback(julia);
//        var feedback = new OverlayFeedback(julia, {feedbackType: OverlayOpacity, showOriginal: false});
//        var feedback = new OverlayFeedback(julia, {feedbackType: OverlayScale, showOriginal: false});
//        var feedback = new OverlayFeedback(julia, {feedbackType: OverlayBlur, showOriginal: false});
//        var feedback = new OverlayFeedback(julia, {feedbackType: OverlayProgressBar, showOriginal: false});
        julia.addEventSource(new PMouseEventHook($sketch[0], mouseVariance, mouseVariance));

        setup();

        var updateUI = function() {
            $sketch.empty();
            julia.drawFeedback($sketch, feedback);
        };
        updateUI();
        // Do stuff when an event has been dispatched
        julia.dispatchCompleted = function(x, uiUpdated) {
            if(!uiUpdated) {
                return;
            }
            updateUI();
//            julia.dumpAlternativesAsSnap($debug, $sketch.width(), $sketch.height(), 0.4);
        };

        addTouchOverlay();
    });

</script>
</body>
</html>