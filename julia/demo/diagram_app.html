<!-- Created on 5/26/2014 -->
<!DOCTYPE html>
<html>
<head>
    <title>Diagramming App</title>

    <!-- Julia library -->
    <script type="text/javascript" src="../dist/julia.js"></script>

    <!-- Julia CSS -->
    <link type="text/css" rel="stylesheet" href="../julia.css"/>

</head>
<body>
<!--<h3 class="centered">Diagramming App</h3>-->
<h3 class="centered" id="last_action">last action: none</h3>
<div id="ipad_container" class="ipad_container">
    <div id="ipad_screen" class="ipad_screen">
        <svg id="demo_interface" width="546" height="407"></svg>
    </div>
</div>
<div id="debug"></div>
<div id="demo_alternatives"></div>

<script>
    // Globals
    var LINE_COLOR = "#333";
    var FILL_COLOR = "#fff";
</script>
<script>
    // Views
    /**
     * Drag out a bounding box containing one of two shapes: circles or rectangles
     */
    var DragShapeView = FSMView.subClass({
        className: "DragShapeView",
        init: function(julia, props) {
            var defaults = {
                default_predicate_probability: 0.6,
                default_predicate_probability_with_prior: 1.0,
                use_priors: false,
                onShapeCompleted: function(shape, view) { console.log("shape", shape, "completed"); }
            };
            this._super(julia, props, defaults);
            this.initFSM();
        },
        initFSM: function() {
            this.fsm_description = { start: []};
            var shapes = ["circle", "rectangle"];
            var me = this;
            shapes.forEach(function(shape) {
                me.fsm_description.start.push(
                        new MouseDownTransitionWithProbability(
                                shape,
                                function() {
                                    if(this.properties.use_priors && window.__julia_last_action === ("drag " + shape)) {
                                        return this.properties.default_predicate_probability_with_prior;
                                    }
                                    return this.properties.default_predicate_probability;
                                },
                                me.updateStart,
                                undefined,
                                true
                        )
                );
                me.fsm_description[shape] = [];
                me.fsm_description[shape].push(
                    new MouseMoveTransition(
                            shape,
                            RETURN_TRUE,
                            me.updateBounds,
                            undefined,
                            true
                    )
                );
                me.fsm_description[shape].push(
                    new MouseUpTransition(
                            "start",
                            function() { return this.properties.p1 && this.properties.p2; },
                            undefined,
                            me.shapeDone.curry(shape),
                            true
                    )
                )
            });

        },
        updateStart: function(e) {
            this.properties.p1 = {x: e.base_event.element_x, y: e.base_event.element_y};
        },
        updateBounds: function(e) {
            this.properties.p2 = {x: e.base_event.element_x, y: e.base_event.element_y};
        },
        draw: function($el) {
            var s = Snap($el[0]);
            var attrs = {
                fill: FILL_COLOR,
                opacity: 0.5,
                stroke: LINE_COLOR
            }
            var p1 = this.properties.p1;
            var p2 = this.properties.p2;
            if(!p1 || !p2) {
                return;
            }
            // top left
            var tl = {x: Math.min(p1.x, p2.x), y: Math.min(p1.y, p2.y)};
            // bottom right
            var br = {x: Math.max(p1.x, p2.x), y: Math.max(p1.y, p2.y)};
            var w = br.x - tl.x;
            var h = br.y - tl.y;
            if(this.current_state === "circle") {
                s.ellipse(tl.x + w/2, tl.y + h/2, w/2, h/2).attr(attrs);
            } else {
                // current_state === "rect"
                s.rect(tl.x, tl.y, w, h).attr(attrs);
            }
        },
        shapeDone: function(shape, e, rootView) {
            var p1 = this.properties.p1;
            var p2 = this.properties.p2;
            // top left
            var tl = {x: Math.min(p1.x, p2.x), y: Math.min(p1.y, p2.y)};
            // bottom right
            var br = {x: Math.max(p1.x, p2.x), y: Math.max(p1.y, p2.y)};
            this.properties.onShapeCompleted(shape, rootView, tl, br);
            delete this.properties.p1;
            delete this.properties.p2;
        }
    });

    var TrashView = FSMView.subClass({
        className: "TrashView",
        init: function(julia, props) {
            var defaults = {
                width: 546,
                height: 30,
                x: 0,
                y: 377
            };
            this._super(julia, props, defaults);
            this.fsm_description = {
                start: [
                /**
                 * attrs: to (required), source (required), type (required), predicate (required), feedback_action (default: undefined)
                 * final_action (default: undefined), handles_event (default: false)
                 * @param attrs
                 */
                    new Transition({
                        to: "active",
                        source: "virtual",
                        type: "dragstart",
                        predicate: RETURN_TRUE,
                        feedback_action: DO_NOTHING,
                        handles_event: false
                    })
                ],
                active: [
                    new Transition({
                        to: "start",
                        source: "virtual",
                        type: "dragend",
                        predicate: RETURN_TRUE,
                        feedback_action: DO_NOTHING,
                        handles_event: false
                    }),
                    new Transition({
                        to: "over",
                        source: "virtual",
                        type: "dragprogress",
                        predicate: this.hitTest,
                        feedback_action: DO_NOTHING,
                        handles_event: false
                    }),
                    new Transition({
                        to: "start",
                        source: "virtual",
                        type: "dragprogress",
                        predicate: this.hitTest,
                        feedback_action: DO_NOTHING,
                        handles_event: false
                    }),
                    new Transition({
                        to: "start",
                        source: "virtual",
                        type: "dragend",
                        predicate: RETURN_TRUE,
                        feedback_action: DO_NOTHING,
                        handles_event: false
                    })
                ],
                over: [
                    new Transition({
                        to: "active",
                        source: "virtual",
                        type: "dragprogress",
                        predicate: this.missTest,
                        feedback_action: DO_NOTHING,
                        handles_event: false
                    }),
                    new Transition({
                        to: "start",
                        source: "virtual",
                        type: "dragend",
                        predicate: RETURN_TRUE,
                        feedback_action: this.onDragEnd,
                        handles_event: false
                    })
                ]
            }
        },
        missTest: function(e) {
            return !this.hitTest(e);
        },
        hitTest: function(e){

            var r1 = e.view.getBoundingBox();
            var r2 = this.getBoundingBox();
            return rectanglesIntersect(r1, r2);
        },
        onDragEnd: function(e, rootView) {
            console.log("onDragEnd");
            rootView.removeChildView(e.view);
        },
        draw: function($el) {
            var s = Snap($el[0]);
            if(this.current_state === "start") {
                return;
            }

            var x = this.properties.x;
            var y = this.properties.y;
            var w = this.properties.width;
            var h = this.properties.height;
            var cx = x + w / 2;
            var cy = y + h / 2 + 5;
            s.rect(x,y,w,h).attr({
                fill:  "red",
                opacity: this.current_state === "over" ? 0.8 :0.4
            });

            s.text(cx, cy, "remove").attr({"text-anchor": "middle", fill: "white"});
        }
    })
</script>
<script>



    /**
     * Set up the interface here
     * @param rootView
     */
    function setup(rootView) {
        var julia = rootView.julia;

        // The path brush draws lines (horizontal and vertical)
        var path_brush = new PathBrush(julia, {color: LINE_COLOR,
            width: 1,
            use_priors: true,
            onLineCompleted: onLineCompleted.curry(julia, LINE_COLOR)});


        // Use the gesture recognizer to add ellipses and rectangles

        var gesture_recognizer = new GestureRecognizer(julia, {
            onGestureRecognized: onGestureCompleted.curry(julia),
            gestures: ["circle", "rectangle"],
            use_priors: true
        });


        var drag_shape = new DragShapeView(julia, {
            onShapeCompleted: onDragShapeCompleted.curry(julia),
            use_priors: true
        });
        var everyChildView = new EveryChildContainerView(julia, {background_color: "#eee"});
        everyChildView.addChildView(drag_shape);
//        everyChildView.addChildView(gesture_recognizer);
        everyChildView.addChildView(path_brush);
        rootView.addChildView(everyChildView);
        var trashView = new TrashView(julia);
        trashView.properties.drawZ = 1000;
        rootView.addChildView(trashView);
    }

    function updateLastAction(action) {
        window.__julia_last_action = action;
        $("#last_action").html("last action: " + action);
    }

    function onLineCompleted (julia, lineColor, p1, p2, root) {
        var new_line = new EditableLine(julia, p1, p2,
                {radius: 1, color: lineColor});
        root.addChildView(new_line);
        // set last action to be line, regardless of if it was horizontal or vertical
        updateLastAction("line");
    };

    function onDragShapeCompleted(julia, shape, rootView, topLeft, bottomRight) {
        var new_shape;
        var w = bottomRight.x - topLeft.x;
        var h = bottomRight.y - topLeft.y;
        if(shape === "circle") {
            new_shape = new DraggableResizeableEllipse(julia, {color: FILL_COLOR,
                "stroke-width": "1px",
                x: topLeft.x, y: topLeft.y , w: w, h: h});
        } else {
            // shape === 'rect'
            new_shape = new DraggableResizeableBox(julia, { color: FILL_COLOR,
            "stroke-width": "1px",
            x: topLeft.x, y: topLeft.y, w: w, h: h});
        }
        if(new_shape) {
            rootView.addChildView(new_shape);
        }

        updateLastAction("drag " + shape);
    }

    function onGestureCompleted(julia, gesture_name, rootView,  gesture_recognizer) {
        var minx = Infinity, miny = Infinity, maxx = 0, maxy = 0, topMost, bottomMost, leftMost, rightMost;
        var path = gesture_recognizer.path;
        for(var i = 0; i < path.length; i++) {
            var p = path[i];
            if(p.x < minx) {
                minx = p.x;
                leftMost = p;
            }
            if(p.y < miny) {
                miny = p.y;
                topMost = p;
            }
            if(p.x > maxx) {
                maxx = p.x;
                rightMost = p;
            }
            if(p.y > maxy) {
                maxy = p.y;
                bottomMost = p;
            }
        }
        var new_shape;
        if(gesture_name === "circle") {
            new_shape = new DraggableResizeableEllipse(julia, {color: FILL_COLOR,
                "stroke-width": "1px",
                x: minx, y: miny, w: (maxx-minx), h: (maxy - miny)});
        } else if (gesture_name === "rectangle") {
            new_shape = new DraggableResizeableBox(julia, {color: FILL_COLOR,
                "stroke-width": "1px",
                x: minx, y: miny, w: (maxx-minx), h: (maxy - miny)});
        }
        if(new_shape) {
            rootView.addChildView(new_shape);
        }

        updateLastAction("gesture");

    }

    function onKeyPress(julia, e) {
        var c = String.fromCharCode(e.keyCode);
        if(c === 'd') {
            // remove the last child unless the size of the children is 1 (in which case it's just the gestures);
            var toProcess = [julia.rootView];
            toProcess.forEach(function(alt) {
                if(alt.children.length > 1) {
                    alt.removeLastChild();
                }
            });
        }

    }
    /**
     * Executed when the document loads. Intended to be boilerplate, shouldn't have to replace much here (for now).
     */
    $(document).ready(function(){

        var julia = new Julia({nSamplesPerEvent: 10, minProbability: 0.01, nAlternativesToKeep: 10});
        var rootView = new ContainerView(julia, {background_color: "#eee"});
        julia.setRootView(rootView);
        setup(rootView);

        var $alternatives = $("#demo_alternatives");
        var $mainInterface = $("#demo_interface");


        // Add an event source
        var mouseHook = new PMouseEventHook($mainInterface[0]);
        julia.addEventSource(mouseHook);
        julia.feedback = new NBestUIFeedback(julia, {
            n: 6,
            probability_mode: "text",
            dp: 1,
            feedback_type: NBestGateLeftAligned,
            show_root_instead_of_most_likely: false,
            n_best_location: function(){return {x: 0, y:0}}});
        julia.dwellForFeedback = true;


        // draw every 30 ms
        var update = function() {
            // HACK: if the requests are ambiguous, dont'draw the regular feedback
            if(julia.__julia_ambiguous) {
                return;
            }
            $mainInterface.empty();
            julia.drawFeedback($mainInterface, julia.feedback);
            //julia.dumpAlternativesAsSnap($alternatives, $mainInterface.width(), $mainInterface.height(), 0.5);
        }
        window.setInterval(update, 30);

        julia.mediator.mediationThreshold = 0.0;

        julia.dispatchCompleted = function() {};
        julia.ambiguousRequests = function(deferred, pEvent) {
            $mainInterface.empty();
            julia.feedback.draw($mainInterface, julia.rootView, deferred);
        }

        addTouchOverlay();
        addKeyOverlay();
        $(document).keypress(onKeyPress.curry(julia));
    });
</script>
</body>
</html>