<!DOCTYPE html>

<html>
<head>
    <title>Focus-Free Text Entry</title>
    <!-- JQuery -->
    <script type="text/javascript" src="../lib/jquery.js"></script>
    <script type="text/javascript" src="../lib/snap.svg.js"></script>

    <script type="text/javascript" src="../julia.js"></script>
    <link rel="stylesheet" type="text/css" href="../julia.css"/>
</head>
<body>
<div id="top_bar"></div>
<h3>Focus-Free Text Entry</h3>
<div id="demo_description">
    A form which does not require focus. Type in text, no need to specify which field. The program will figure it out.
    NOTE: To delete, press 'x', not backspace (sorry, that doesn't work for now)
    <div>voice status:</div>
    <div id="status"></div>
</div>

<div id="demo_settings">
    <div>
        <input id="dbg_dumptext" type="checkbox" />
        <label for="dbg_dumptext">dump alternatives as text</label>
    </div>

    <div>
        <input id="dbg_dumpsnap" type="checkbox" checked="true"/>
        <label for="dbg_dumpsnap">dump alternative renderings</label>

    </div>

    <input type="button" id="start_speech" value="start speech"/>
    <input type="button" id="stop_speech" value="stop speech"/>
    <input type="button" id="reset_button" value="reset"/>
</div>

<table>
    <tr>
        <td>
            <svg id="demo_interface" class="border1px" width="500" height="400"></svg>
        </td>
        <td>
            <div id="demo_alternatives"></div>
        </td>
    </tr>
</table>
<div id="debug"></div>

<script>
var FormEntry = FSMView.subClass({
    // TODO: Migrate this to using properties when you feel like doing mindless refactoring
    className: "FormLabel",
    init: function(julia, label, inputValidFunction, entryTextValidFunction, x, y, onCompleteFn) {
        this._super(julia);
        this.entry_text = "";
        this.entry_opacity = 0.6;
        this.x = x;
        this.y = y;
        this.width = 400;
        this.height = 30;
        this.label = label;
        this.message = "";
        this.onCompleteFn = onCompleteFn;
        this.validFunction = inputValidFunction;
        this.entryTextValidFunction = entryTextValidFunction;
        this.interim_text = "";
        this.fsm_description = {
            start: [
                new KeypressTransition(
                        "textEntered",
                        function(e) {
                            return !(e.keyCode == 9 || e.keyCode == 13 || String.fromCharCode(e.keyCode) === "x") &&
                                    this.validFunction(String.fromCharCode(e.keyCode));
                        },
                        function(e) {
                            this.entry_opacity = 0.6;
                            this.entry_text += String.fromCharCode(e.keyCode);
                            this.container.setFocus(this);
                            this.message = "keep going...";
                        }, // feedback
                        undefined,
                        true
                ),
                new VoiceTransition(
                        "voiceEntered",
                        "interim",
                        function(e) { return this.validFunction(e.transcript); },
                        function(e) {
                            this.entry_opacity = 0.6;
                            this.entry_text = e.transcript;
                            this.container.setFocus(this);
                            this.message = "keep going...";
                        },
                        undefined,
                        true
                        // to,source,type,predicate,feedback_action,final_action,handles_event)
                ),
                new VoiceTransition(
                        "start",
                        "interim",
                        function(e) { return true },
                        function(e) {},
                        undefined,
                        true
                        // to,source,type,predicate,feedback_action,final_action,handles_event)
                )
            ],
            voiceEntered: [
                new VoiceTransition(
                        "voiceEntered",
                        "interim",
                        function(e) { return this.validFunction(e.transcript); },
                        function(e) {
                            this.entry_opacity = 0.6;

                            this.message = "keep going...";
                        },
                        undefined,
                        true
                        // to,source,type,predicate,feedback_action,final_action,handles_event)
                ),
                new VoiceTransition(
                        "done",
                        "final",
                        function(e) { return this.entryTextValidFunction(e.transcript); },
                        undefined,
                        this.entry_completed,
                        true
                        // to,source,type,predicate,feedback_action,final_action,handles_event)
                ),
                new MouseDownTransition(
                        "done",
                        function(e) {
                            return this.predicate_mouse_in_region(e) && this.entryTextValidFunction(this.entry_text);
                        },
                        undefined,
                        this.entry_completed,
                        true
                ),
                new MouseDownTransition(
                        "voiceEntered",
                        function(e) {
                            return this.predicate_mouse_in_region(e) && !this.entryTextValidFunction(this.entry_text);
                        },
                        function() {
                            this.message = "not valid!"
                        },
                        undefined,
                        false
                ),
            ],
            textEntered : [
                // voice and interim (assume entry is valid?)

            /** Pressing the enter key and entry is valid **/
                new MouseDownTransition(
                        "done",
                        function(e) {
                            return this.predicate_mouse_in_region(e) && this.entryTextValidFunction(this.entry_text);
                        },
                        undefined,
                        this.entry_completed,
                        true
                ),
                new MouseDownTransition(
                        "textEntered",
                        function(e) {
                            return this.predicate_mouse_in_region(e) && !this.entryTextValidFunction(this.entry_text);
                        },
                        function() {
                            this.message = "not valid!"
                        },
                        undefined,
                        false
                ),
                new KeypressTransition(
                        "done",
                        function(e, rootView) { return e.keyCode == 13 && this.entryTextValidFunction(this.entry_text); }, // 9 is tab, 13 is enter
                        undefined,
                        this.entry_completed, // final
                        true
                ),
            /** Pressing the enter key but entry is invalid **/
                new KeypressTransition(
                        "textEntered",
                        function(e) { return e.keyCode == 13 && !this.entryTextValidFunction(this.entry_text); }, // 9 is tab, 13 is enter
                        function() {
                            this.message = "not valid!"
                        },
                        undefined, // final
                        true
                ),
            /** Pressing 'x' deletes text...if no text then we shoudl clear our focus **/
                new KeypressTransition(
                        "start",
                        function(e) {
                            return String.fromCharCode(e.keyCode) === "x" && this.entry_text.length <= 1;
                        },
                        function(e) {
                            this.entry_text = "";
                            this.container.clearFocus();
                            this.message = "";
                        },
                        undefined,
                        true
                ),
            /** Pressing some other key. Check if the text is valid if not, we should kill the alternative. If it is valid, then keep doing **/
                new KeypressTransition(
                        "textEntered",
                        function(e) {
                            return !(e.keyCode == 9 || e.keyCode == 13) &&
                                    !(String.fromCharCode(e.keyCode) === "x" && this.entry_text.length <= 1);
                        },
                        function(e, rootView) {
                            if(!(this.validFunction(String.fromCharCode(e.keyCode)))) {
                                rootView.kill = true;
                                return;
                            }
                            if(String.fromCharCode(e.keyCode) === "x") {
                                this.entry_text = this.entry_text.substring(0, this.entry_text.length - 2);
                            } else {
                                this.entry_text += String.fromCharCode(e.keyCode);
                                this.message = "keep going...";
                            }


                        }, // feedback
                        undefined,
                        true
                )
            ],
            done: [

            ]
        }
    },
    predicate_mouse_in_region: function(e) {
        var rx = e.element_x - this.x;
        var ry = e.element_y - this.y + this.height;
        var result = rx > 0 && ry > 0 && rx < this.width && ry < this.height;
        log(LOG_LEVEL_DEBUG, e.element_x, e.element_y, this.label, "rx:", rx, "ry:", ry, result);
        return result;
    },
    entry_completed: function(e) {
        this.message = "complete";
        this.entry_opacity = 1.0;
        this.container.clearFocus();
        if(typeof this.onCompleteFn !== 'undefined') {
            this.onCompleteFn(this, rootView);
        }
    },
    draw: function($el) {
        var s = Snap($el[0]);
        s.text(this.x,this.y, this.label + ": ");
        s.text(this.x + 140, this.y, this.entry_text).attr({opacity: this.entry_opacity, "font-family": "monospace"});
        s.text(this.x + 300, this.y, this.message);
        var color = "rgb(0,0,0)";
        if(this.current_state == "textEntered") {
            var char_width = 8;

            s.line(this.x + 140 + this.entry_text.length * char_width, this.y, this.x + 140 + this.entry_text.length * char_width + 7, this.y)
                    .attr({stroke: "rgb(0,0,0)"});
        }
//        var color = "rgb(200,200,200)";
//        if(this.current_state == "textEntered") {

//        }
        s.rect(this.x + 130, this.y - this.height + 10, this.width - 250, this.height).attr({"fill-opacity": 0, "stroke-width": 1, stroke: color});
    },
    clone: function() {
        var result = new FormEntry(this.julia, this.label, this.validFunction, this.entryTextValidFunction, this.x, this.y);
        this.copyFsm(result);
        this.cloneActionRequests(result);
        result.entry_text = this.entry_text;
        result.entry_opacity = this.entry_opacity;
        result.message = this.message;
        result.onCompleteFn = this.onCompleteFn;
        result.interim_text = this.interim_text;
        return result;
    },
    equals: function(other) {
        if(!this._super(other)) {
            return false;
        }
        return this.label === other.label && this.entry_text === other.entry_text && this.interim_text === other.interim_text;
    }
});
</script>

<script>

var $sketch = $("#demo_interface");
var $sketches = $("#demo_alternatives");
var $state = $("#status");

var source = new PVoiceEventSource();
source.onerror = function(event) {
    if (event.error == 'no-speech') {
        $state.html("No speech was detected. You may need to adjust your microphone settings");
    }
    if (event.error == 'audio-capture') {
        $state.html("No microphone installed");
    }
    if (event.error == 'not-allowed') {
        $state.html("Click the 'Allow' button above to enable your microphone");
    }
};
source.onend = function() {
    $state.html("speech ended");
};
source.onstart = function() {
    $state.html("speech started. Speak into microphone.");
};
source.onend = function() {
    $state.html("speech stopped.");
};


$("#dbg_dumptext").click(function(){
    $("#debug").empty();
});
$("#dbg_dumpsnap").click(function(){
    $("#alternative_interfaces").empty();
});

$("#reset_button").click(function(){
    reset();
});

function reset() {
    var rootView = new ContainerView(julia);
    julia.setRootView(rootView);

    var labelx = 50;
    var starty = 50;
    var dy = 50;
    var fields = [];
    fields.push(new FormEntry(julia, "name (last, first)", function(input) { return /[a-zA-z, ]+/.test(input);},
            function(current_text) { return /^\s*\w+\s*,\s*\w+\s*$/.test(current_text)},
            labelx, starty
    ));
    starty += dy;

    fields.push(new FormEntry(julia, "dob (mm/dd/yyyy)", function(input) { return /[0-9\/x ]+/.test(input);},
            function(current_text) { return /^[ ]*\d{2}[ ]*\/[ ]*\d{2}[ ]*\/[ ]*\d{4}[ ]*$/.test(current_text)},
            labelx, starty
    ));
    starty += dy;

    fields.push(new FormEntry(julia, "email", function(input) { return /[\w@\.]+/.test(input);},
            function(currentText) { return /^\w+@\w+\.[a-zA-Z]+$/.test(currentText); }, labelx, starty)); // (julia, label, validFunction, x, y) {)
    starty += dy;


    fields.push(new FormEntry(julia, "ssn", function(input) { return /[x\d]+/.test(input) && /^\d{0,8}$/.test(this.entry_text); },
            function(current_text) { return /^\d{9}$/.test(current_text)}, labelx, starty));
    starty += dy;
    fields.push(new FormEntry(julia, "phone", function(input) { return /[x\d]+/.test(input) && /^\d{0,9}$/.test(this.entry_text); },
            function(current_text) { return /^(\d{10}|\d{7})$/.test(current_text)}, labelx, starty));
    starty += dy;
    fields.push(new FormEntry(julia, "favorite fruit", function(input) { return /[a-z]+/.test(input); },
            function(current_text) { return /^(apple|orange|banana)$/.test(current_text)}, labelx, starty));

    starty += dy;
    fields.push(new FormEntry(julia, "favorite color", function(input) { return /[a-z]+/.test(input); },
            function(current_text) { return /^(red|yellow|blue|orange)$/.test(current_text)}, labelx, starty));

    fields.forEach(function(f){
        rootView.addChildView(f);
    });
//    var cursor = new Cursor(julia);
//    rootView.addChildView(cursor);
    $sketch.empty();
    $("#debug").empty();
    $("#alternative_interfaces").empty();
    rootView.draw($sketch);
}

var julia = new Julia();
var feedback = new SimpleFeedback(julia, {feedbackType: FeedbackOpacityView1});
julia.nSamplesPerEvent = 1;

julia.dispatchCompleted = function(new_alternatives, uiUpdated) {
    if(!uiUpdated) {
        return;
    }

    $sketch.empty();
    var merged = julia.drawFeedback($sketch, feedback);


    if($("#dbg_dumptext").is(':checked')) {
        merged.domDump($("#debug"));
    }

    if($("#dbg_dumpsnap").is(':checked')) {
        julia.dumpAlternativesAsSnap($sketches, $sketch.width(), $sketch.height(), 0.5, function() {
            $sketch.empty();
            julia.rootView.draw($sketch);
            julia.dumpAlternativesAsSnap($sketches, $sketch.width(), $sketch.height(), 0.5);
        });
    }

};
julia.addEventSource(new PKeyEventHook(document));
var mHook = new PMouseEventHook($sketch[0]);

mHook.variance_x_px = 1;
mHook.variance_y_px = 1;
julia.addEventSource(mHook);
julia.addEventSource(source);
reset();
$("#start_speech").click(function(){
    source.start();
});
$("#stop_speech").click(function(){
    source.stop();
});

</script>


</body>
</html>