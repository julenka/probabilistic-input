<!DOCTYPE html>
<!--
Form Option 1:
As you type, text gets entered in to the object that is in focus
If no object is in focus, then a random object is picked to be in focus and then input dispatched
When you press tab, the focus is again set to null
When you press submit, pick the most likely form, then check that all fields are in. if so, log to console (or something)

Form Option 2:
As you type, a 'text entry' feedback item shows you the letters entered (maybe not even probabilistic)
When you press tab, a 'form input' event is sent, and dispatched to a random interactor
Show feedback by updating the possible interfaces
When you press enter, a finalization request is made, the most likely interface is then shown
-->
<html>
<head>
    <title>Form Demo</title>
    <!-- JQuery -->
    <script type="text/javascript" src="../lib/jquery.js"></script>
    <script type="text/javascript" src="../lib/snap.svg.js"></script>

    <script type="text/javascript" src="../julia.js"></script>
    <link rel="stylesheet" type="text/css" href="../julia.css"/>
</head>
<body>
<input type="button" id="start_speech" value="start speech"/>
<input type="button" id="stop_speech" value="stop speech"/>
<div>voice status:</div>
<div id="status"></div>
<table>

    <tr>
        <td>
            <input id="dbg_dumptext" type="checkbox" />
            <label for="dbg_dumptext">dump alternatives as text</label>
        </td>

    </tr>
    <tr>
        <td>
            <input id="dbg_dumpsnap" type="checkbox" checked="true"/>
            <label for="dbg_dumpsnap">dump alternative renderings</label>
        </td>
    </tr>
    <tr>
        <td>
            <input type="button" id="reset_button" value="reset"/>
        </td>
    </tr>
    <tr><td>Go ahead, type something! NOTE: To delete, press 'x', not backspace (sorry, that doesn't work for now)</td></tr>
    <tr>
        <td>
            <svg id="main_interface" class="border1px" width="500" height="300"></svg>
        </td>
        <td>
            <div id="alternative_interfaces"></div>
        </td>
    </tr>
</table>
<div id="debug">

</div>

<script>
var FormEntry = FSMView.subClass({
    className: "FormLabel",
    init: function(julia, label, inputValidFunction, entryTextValidFunction, x, y, onCompleteFn) {
        this._super(julia);
        this.entry_text = "";
        this.entry_opacity = 0.6;
        this.x = x;
        this.y = y;
        this.label = label;
        this.message = "";
        this.onCompleteFn = onCompleteFn;
        this.validFunction = inputValidFunction;
        this.entryTextValidFunction = entryTextValidFunction;
        this.interim_text = "";
        this.fsm_description = {
            start: [
                new KeypressTransition(
                        "textEntered",
                        function(e) {
                            return !(e.keyCode == 9 || e.keyCode == 13 || String.fromCharCode(e.keyCode) === "x") &&
                                    this.validFunction(String.fromCharCode(e.keyCode));
                        },
                        function(e) {
                            this.entry_opacity = 0.6;
                            this.entry_text += String.fromCharCode(e.keyCode);
                            this.container.setFocus(this);
                            this.message = "keep going...";
                        }, // feedback
                        undefined,
                        true
                ),
                new VoiceTransition(
                        "textEntered",
                        "interim",
                        function(e) { return this.validFunction(e.transcript); },
                        function(e) {
                            this.entry_opacity = 0.6;
                            this.interim_text = e.transcript;
                            this.container.setFocus(this);
                            this.message = "keep going...";
                        },
                        undefined,
                        true
                        // to,source,type,predicate,feedback_action,final_action,handles_event)
                ),
                new VoiceTransition(
                        "textEntered",
                        "final",
                        function(e) { return this.validFunction(e.transcript); },
                        function(e) {
                            this.entry_opacity = 0.6;
                            this.entry_text += e.transcript;
                            this.interim_text = "";
                            this.container.setFocus(this);
                            this.message = "keep going...";
                        },
                        undefined,
                        true
                        // to,source,type,predicate,feedback_action,final_action,handles_event)
                )
            ],
            textEntered : [
                    // voice and interim (assume entry is valid?)

                new VoiceTransition(
                        "textEntered",
                        "interim",
                        function(e) { return this.validFunction(e.transcript); },
                        function(e) {
                            this.entry_opacity = 0.6;
                            this.interim_text = e.transcript;
                            this.message = "keep going...";
                        },
                        undefined,
                        true
                        // to,source,type,predicate,feedback_action,final_action,handles_event)
                ),
                new VoiceTransition(
                        "textEntered",
                        "final",
                        function(e) { return this.validFunction(e.transcript); },
                        function(e) {
                            this.entry_opacity = 0.6;
                            this.entry_text += e.transcript;
                            this.interim_text = "";
                            this.message = "keep going...";
                        },
                        undefined,
                        true
                        // to,source,type,predicate,feedback_action,final_action,handles_event)
                ),
                /** Pressing the enter key and entry is valid **/
                new KeypressTransition(
                        "done",
                        function(e, rootView) { return e.keyCode == 13 && this.entryTextValidFunction(this.entry_text); }, // 9 is tab, 13 is enter
                        undefined,
                        function(e, rootView) {
                            this.message = "complete";
                            this.entry_opacity = 1.0;
                            this.container.clearFocus();
                            if(typeof this.onCompleteFn !== 'undefined') {
                                this.onCompleteFn(this, rootView);
                            }
                        }, // final
                        true
                ),
                /** Pressing the enter key but entry is invalid **/
                new KeypressTransition(
                        "textEntered",
                        function(e) { return e.keyCode == 13 && !this.entryTextValidFunction(this.entry_text); }, // 9 is tab, 13 is enter
                        function(e) {
                            this.message = "not valid!"
                        },
                        undefined, // final
                        true
                ),
                /** Pressing 'x' deletes text...if no text then we shoudl clear our focus **/
                new KeypressTransition(
                        "start",
                        function(e) {
                            return String.fromCharCode(e.keyCode) === "x" && this.entry_text.length <= 1;
                        },
                        function(e) {
                            this.entry_text = "";
                            this.container.clearFocus();
                            this.message = "";
                        },
                        undefined,
                        true
                ),
                /** Pressing some other key. Check if the text is valid if not, we should kill the alternative. If it is valid, then keep doing **/
                new KeypressTransition(
                        "textEntered",
                        function(e) {
                            return !(e.keyCode == 9 || e.keyCode == 13) &&
                                    !(String.fromCharCode(e.keyCode) === "x" && this.entry_text.length <= 1);
                        },
                        function(e, rootView) {
                            if(!(this.validFunction(String.fromCharCode(e.keyCode)))) {
                                rootView.kill = true;
                                return;
                            }
                            if(String.fromCharCode(e.keyCode) === "x") {
                                this.entry_text = this.entry_text.substring(0, this.entry_text.length - 2);
                            } else {
                                this.entry_text += String.fromCharCode(e.keyCode);
                                this.message = "keep going...";
                            }


                        }, // feedback
                        undefined,
                        true
                )
            ],
            done: [

            ]
        }
    },
    draw: function($el) {
        var s = Snap($el[0]);
        s.text(this.x,this.y, this.label + ": ");
        s.text(this.x + 130, this.y, this.entry_text + this.interim_text).attr({opacity: this.entry_opacity});
        s.text(this.x + 300, this.y, this.message);
    },
    clone: function() {
        var result = new FormEntry(this.julia, this.label, this.validFunction, this.entryTextValidFunction, this.x, this.y);
        this.copyFsm(result);
        this.cloneActionRequests(result);
        result.entry_text = this.entry_text;
        result.entry_opacity = this.entry_opacity;
        result.message = this.message;
        result.onCompleteFn = this.onCompleteFn;
        result.interim_text = this.interim_text;
        return result;
    },
    equals: function(other) {
        if(!this._super(other)) {
            return false;
        }
        return this.label === other.label && this.entry_text === other.entry_text && this.interim_text === other.interim_text;
    }
});

var $sketch = $("#main_interface");
var $sketches = $("#alternative_interfaces");
var $state = $("#status");

var source = new PVoiceEventSource();
source.onerror = function(event) {
    if (event.error == 'no-speech') {
        $state.html("No speech was detected. You may need to adjust your microphone settings");
    }
    if (event.error == 'audio-capture') {
        $state.html("No microphone installed");
    }
    if (event.error == 'not-allowed') {
        $state.html("Click the 'Allow' button above to enable your microphone");
    }
};
source.onend = function() {
    $state.html("speech ended");
};
source.onstart = function() {
    $state.html("speech started. Speak into microphone.");
};
source.onend = function() {
    $state.html("speech stopped.");
};


$("#dbg_dumptext").click(function(){
    $("#debug").empty();
});
$("#dbg_dumpsnap").click(function(){
    $("#alternative_interfaces").empty();
});

$("#reset_button").click(function(){
    reset();
});

function reset() {
    var rootView = new ContainerView(julia);
    julia.setRootView(rootView);

    var labelx = 50;
    var starty = 50;
    var dy = 30;
    var fields = [];
    fields.push(new FormEntry(julia, "name (last, first)", function(input) { return /[a-zA-z, ]+/.test(input);},
            function(current_text) { return /^\s*\w+\s*,\s*\w+\s*$/.test(current_text)},
            labelx, starty
    ));
    starty += dy;

    fields.push(new FormEntry(julia, "dob (mm/dd/yyyy)", function(input) { return /[0-9\/x]+/.test(input);},
            function(current_text) { return /^\d{2}\/\d{2}\/\d{4}$/.test(current_text)},
            labelx, starty
    ));
    starty += dy;

    fields.push(new FormEntry(julia, "email", function(input) { return /[\w@\.]+/.test(input);},
            function(currentText) { return /^\w+@\w+\.[a-zA-Z]+$/.test(currentText); }, labelx, starty)); // (julia, label, validFunction, x, y) {)
    starty += dy;


    fields.push(new FormEntry(julia, "ssn", function(input) { return /[x\d]+/.test(input) && /^\d{0,8}$/.test(this.entry_text); },
            function(current_text) { return /^\d{9}$/.test(current_text)}, labelx, starty));
    starty += dy;
    fields.push(new FormEntry(julia, "phone", function(input) { return /[x\d]+/.test(input) && /^\d{0,9}$/.test(this.entry_text); },
            function(current_text) { return /^(\d{10}|\d{7})$/.test(current_text)}, labelx, starty));
    starty += dy;
    fields.push(new FormEntry(julia, "fruit", function(input) { return /[a-z]+/.test(input); },
            function(current_text) { return /^(apple|orange|banana)$/.test(current_text)}, labelx, starty));

    starty += dy;
    fields.push(new FormEntry(julia, "vegetable", function(input) { return /[a-z]+/.test(input); },
            function(current_text) { return /^(bean|carrot|potato)$/.test(current_text)}, labelx, starty));

    fields.forEach(function(f){
        rootView.addChildView(f);
    })
    $sketch.empty();
    $("#debug").empty();
    $("#alternative_interfaces").empty();
    rootView.draw($sketch);
}

var julia = new Julia();
julia.nSamplesPerEvent = 1;

julia.dispatchCompleted = function(new_alternatives, uiUpdated) {
    if(!uiUpdated) {
        return;
    }

    $sketch.empty();
    if($("#dbg_dumptext").is(':checked')) {
        julia.dumpAlternativesAsText($("#debug"));
    }
    if($("#dbg_dumpsnap").is(':checked')) {
        julia.dumpAlternativesAsSnap($sketches, $sketch.width(), $sketch.height(), 0.5);
    }

    new_alternatives.forEach(function(view_probability, i) {
        view_probability.view.draw($sketch);
    });
};
julia.addEventSource(new PKeyEventHook(document));
julia.addEventSource(source);
reset();

$("#start_speech").click(function(){
    source.start();
});
$("#stop_speech").click(function(){
    source.stop();
});

</script>


</body>
</html>